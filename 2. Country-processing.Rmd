---
title: "Master's Thesis Code - Data Pre-processing"
author: "Ana PÃ©rez Barrera"
date: "`r Sys.Date()`"
output: html_document
---

```{=html}
<style>
body {
text-align: justify}
</style>
```

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/LG/Desktop/TFM/FINAL-COUNTRY-DATA", echo=TRUE, warning=FALSE,message=FALSE)
```

```{r, include=FALSE}
library(car)
library(caret)
library(cowplot)
library(corrplot)
library(dplyr)
library(ggplot2)
library(ggcorrplot)
library(ggpubr)
library(gbm)
library(glmnet)
library(mice)
library(patchwork)
library(pdp)
library(randomForest)
library(readr)
library(reshape)
library(scales)
library(stringr)
library(sf)
library(tidyverse)
library(tidyr)
```


## 1. LABOR FORCE SURVEY DATA PRE-PROCESSING

Fuction created to perform the ISCO transformation from 3 to 2 digit

```{r, eval=FALSE}
# Create a function to extract the first two digits of ISCO 3-digit codes
extract_ISCO <- function(isco3d) {
  substr(isco3d, 1, 2)
}
```

### Handling missing values in LFS

Iteration over each COUNTRY/dataset to clean and process the data: ISCO Transformation and transforming missing values. Save one final processed file for each country

```{r, eval=FALSE}
# List all CSV files in your working directory
csv_files <- list.files(pattern = "\\.csv$")

# Iterate over each CSV file
for (file in csv_files) {
  # Read the CSV file
  data <- read.csv(file)
  
  # ISCO transformation from 3 to 2 digit
  # Apply the fucntion to ISCO variable (2-digit extraction)
  data$isco <- extract_ISCO(data$ISCO)
  data <- data |> dplyr::select(-ISCO)
  # Convert ISCO 99 in NA
  data$isco[data$isco == 99] <- NA
  
  # Being in employment: EMPSTAT
  # Removing Out of labor force (EMPSTAT=9)
  data$EMPSTAT[data$EMPSTAT == 9] <- NA
  data <- data[!is.na(data$EMPSTAT), ]
  # Removing not employed (EMPSTAT=2)
  data <- subset(data, EMPSTAT != 2)
  
  # Independent variables: labour market participation
  data$HOMEWORK[data$HOMEWORK == 9] <- NA
  data$FTPT[data$FTPT == 9] <- NA
  data$SUPVISOR[data$SUPVISOR == 9] <- NA
  
  # Independent variables: working conditions (working hours and time arrangements)
  data <- data[, names(data) != "HWUSUAL"]
  data$EXTRAHRS[data$EXTRAHRS == 99] <- NA
  data$SHIFTWK[data$SHIFTWK == 9] <- NA
  data$EVENWK[data$EVENWK == 9] <- NA
  data$NIGHTWK[data$NIGHTWK == 9] <- NA
  data$SATWK[data$SATWK == 9] <- NA
  data$SUNWK[data$SUNWK == 9] <- NA

   # Create the new file name with "_final"
  final_file <- sub("\\.csv$", "_final.csv", file)
  
  # Save the modified data back to CSV file with the new name
  write.csv(data, file = final_file, row.names = FALSE)
  
}
```

##  2. JOINT RESEARCH CENTER DATA PRE-PROCESSING

```{r, eval=FALSE}
tasks <- read_delim("tasks eu isco2d nace2d EU15.csv", 
                     delim = "\t", escape_double = FALSE, 
                     trim_ws = TRUE)

# Save vector of unique occupations before removing them
occupation <- unique(tasks$isco)

isco_df <- data.frame(
  isco = as.numeric(gsub("\\..*", "", occupation)),
  job = gsub("^\\d+\\.\\s*", "", occupation)
)

# Save isco_df for later
# write.csv(isco_df, "isco_df.csv", row.names = F)
```

### NA imputation

```{r, eval=FALSE}
# Remove text from ISCO column
tasks$isco <- gsub("[^0-9]+", "", tasks$isco)
# Removing nace and pop variables
tasks<- tasks |>  dplyr::select (-nace,-pop)

#NA imputation with MICE method
set.seed(123)
m = 5 
mice_mod <- mice(tasks, m=m, method='rf')
isco2d <- complete(mice_mod, action=m)

sapply(isco2d, function(x) sum(is.na(x))*100/nrow(isco2d))

# Save isco2d for later
write.csv(isco2d, "isco2d.csv", row.names = F)
```

**Define Country Data**

```{r}
country_data <- list(
  AT_Austria="AT-Austria_final.csv",
  BE_Belgium = "BE-Belgium_final.csv",
  DE_Germany = "DE-Germany_final.csv",
  DK_Denmark = "DK-Denmark_final.csv",
  EL_Greece = "EL-Greece_final.csv",
  ES_Spain = "ES-Spain_final.csv",
  FI_Finland = "FI-Finland_final.csv",
  FR_France = "FR-France_final.csv",
  IE_Ireland ="IE-Ireland_final.csv",
  IT_Italy = "IT-Italy_final.csv",
  LU_Luxembourg="LU-Luxembourg_final.csv",
  NL_Netherlands = "NL-Netherlands_final.csv",
  NO_Norway = "NO-Norway_final.csv",
  PT_Portugal = "PT-Portugal_final.csv",
  SE_Sweden = "SE-Sweden_final.csv"
)
```

### Ratios by country-occupation-year

#### A. Female ratio

Create female ratio from 0 (fully masculine occupation) to 1 (fully feminine occupation).

```{r}
female_ratio <- function(data) {
data <- data %>%
    group_by(YEAR, isco) %>%
    summarise(
      male_count = sum(SEX == 1,  na.rm = TRUE),
      female_count = sum(SEX == 2,  na.rm = TRUE) ) %>%
    mutate(
      total = male_count + female_count,
      femratio = female_count / total ) %>%
    mutate(
      femratio = round(femratio, 4)) |> 
    select(YEAR, isco, femratio) |> 
   left_join(data, by = c("YEAR", "isco")) |> 
    dplyr::select(-SEX)

return(data)
} 
```

#### B. Independent variables: labor market participation

-   **HOMEWORK**: Working at home for the main job (EMPSTAT=1): 1 Person mainly works at home, 2 Person sometimes works at home, 3 Person never works at home.

Create an online-work ratio from 0 (fully in person) to 1 (fully digitalized/online work)

In this code, the total sum of persons working at home is calculated, considering that persons working both at home and in the office (both_count) have a weight of 0.5. Then, the work-at-home ratio is calculated by dividing the sum of the count of persons working exclusively at home and half of the count of persons working at home and in the office by the total.

```{r}
online_ratio <- function(data) {
  data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      online_count = sum(HOMEWORK == 1, na.rm = TRUE),
      both_count = sum(HOMEWORK == 2, na.rm = TRUE), 
      office_count =sum(HOMEWORK ==3, na.rm = TRUE)) |> 
    mutate(
      total = online_count + both_count * 0.5 + office_count,
      onratio = (online_count + both_count * 0.5) / total) |> 
    mutate(onratio = round(onratio, 4)) |>
      select(YEAR, isco, onratio) |> 
     left_join(data, by = c("YEAR", "isco")) |> 
     dplyr::select(-HOMEWORK)
  
  return(data)
} 
```

-   **FTPT**: Full- or part-time main job (self-defined) (EMPSTAT=1): 1 Full-time job, 2 Part-time job

Create full-time/part-time ratio from 0 (part-time) to 1 (full-time).

```{r}
ftpt_ratio <- function(data) {
  data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      ft_count = sum(FTPT == 1, na.rm = TRUE),
      pt_count = sum(FTPT == 2, na.rm = TRUE)) |> 
    mutate(
      total = ft_count + pt_count,
      ftratio = ft_count / total) |> 
    mutate(ftratio = round(ftratio, 4)) |> 
    select(YEAR, isco, ftratio) |> 
    left_join(data, by = c("YEAR", "isco")) |> 
    dplyr::select(-FTPT)
  
  return(data)
}
```

-   **SUPVISOR**: Supervisory responsibilities in main job
-   1 Yes
-   2 No

Create supervisor responsability ratio from 0 (no supervisory responsabilites) to 1 (supervisory responsabilities).

```{r}
supvisor_ratio <- function(data) {
  
  data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      supvisor_yes = sum(SUPVISOR == 1, na.rm = TRUE),
      supvisor_no = sum(SUPVISOR == 2, na.rm = TRUE)) |> 
    mutate(
      total = supvisor_yes + supvisor_no,
      supratio = supvisor_yes / total) |> 
    mutate(supratio = round(supratio, 4)) |> 
    select(YEAR, isco, supratio) |> 
    left_join(data, by = c("YEAR", "isco")) |> 
    dplyr::select(-SUPVISOR)
  
  return(data)
}
```

#### B. Independent variables: working conditions

-   **EXTRAHRS**: Overtime or extra hours worked in main job: 0 No overtime or extra hours in the main job, 0.5-95, Number of hours of overtime or extra hours in the main job (with one possible decimal for half hours). We create a ratio for:
-   0 - None Extra hours.
-   1 - Yes Extra hours

```{r}
extrahrs_ratio <- function(data) {
  
  data <- data |> 
    mutate( EXTRAHRS = case_when(
    EXTRAHRS == 0 ~ "0",
    EXTRAHRS < 20 ~ "1"
  ))
 
   data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      extra_no = sum(EXTRAHRS == 0,  na.rm = TRUE),
      extra_yes = sum(EXTRAHRS == 1,  na.rm = TRUE)) |> 
    mutate(
      total = extra_no + extra_yes,
      extraratio = extra_yes / total) |> 
    mutate(extraratio = round(extraratio, 4)) |> 
      select(YEAR, isco, extraratio)|> 
    left_join(data, by = c("YEAR", "isco")) |> 
    dplyr::select(-EXTRAHRS)
  
  return(data)
}
```

-   **SHIFTWK**: Shift work in main job (1- Person usually does shift work. 3- Person never does)

```{r}
shiftwk_ratio <- function(data) {
 
   data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      shift_no = sum(SHIFTWK == 3,  na.rm = TRUE),
      shift_yes = sum(SHIFTWK == 1,  na.rm = TRUE)) |> 
    mutate(
      total = shift_no + shift_yes,
      shiftratio = shift_yes / total) |> 
    mutate(shiftratio = round(shiftratio, 4)) |> 
      select(YEAR, isco, shiftratio)|> 
    left_join(data, by = c("YEAR", "isco")) |> 
      dplyr::select(-SHIFTWK)
  
  return(data)
}
```

-   **EVENWK**: Evening work in main job

-   **NIGHTWK**: Night work in main job

-   **SATWK**: Saturday work in main job

-   **SUNWK**: Sunday work in main job

1- Person frequently. 2- Person sometimes. 3- Person never

```{r}
shifts_ratio <- function(data) {
  
  data <- data |> 
    group_by(YEAR, isco) |> 
    summarise(
      freq_count = sum(EVENWK == 1, na.rm = TRUE),
      both_count = sum(EVENWK == 2, na.rm = TRUE), 
      never_count =sum(EVENWK ==3, na.rm = TRUE)) |> 
    mutate(
      total = freq_count + both_count * 0.5 + never_count,
      evenratio = (freq_count + both_count * 0.5) / total) |> 
    mutate(evenratio = round(evenratio, 4)) |>
      select(YEAR, isco, evenratio) |> 
     left_join(data, by = c("YEAR", "isco"))
  
    data <- data %>%
      group_by(YEAR, isco) |> 
    summarise(
      freq_count = sum(NIGHTWK == 1, na.rm = TRUE),
      both_count = sum(NIGHTWK == 2, na.rm = TRUE), 
      never_count =sum(NIGHTWK ==3, na.rm = TRUE)) |> 
    mutate(
      total = freq_count + both_count * 0.5 + never_count,
      nightratio = (freq_count + both_count * 0.5) / total) |> 
    mutate(nightratio = round(nightratio, 4)) |>
      select(YEAR, isco, nightratio) |> 
     left_join(data, by = c("YEAR", "isco"))
   
    data <- data %>%
      group_by(YEAR, isco) |> 
      summarise(
      freq_count = sum(SATWK == 1, na.rm = TRUE),
      both_count = sum(SATWK == 2, na.rm = TRUE), 
      never_count =sum(SATWK ==3, na.rm = TRUE)) |> 
    mutate(
      total = freq_count + both_count * 0.5 + never_count,
      satratio = (freq_count + both_count * 0.5) / total) |> 
    mutate(satratio = round(satratio, 4)) |>
      select(YEAR, isco, satratio) |> 
     left_join(data, by = c("YEAR", "isco"))
    
    data <- data %>%
      group_by(YEAR, isco) |> 
      summarise(
      freq_count = sum(SUNWK == 1, na.rm = TRUE),
      both_count = sum(SUNWK == 2, na.rm = TRUE), 
      never_count =sum(SUNWK ==3, na.rm = TRUE)) |> 
    mutate(
      total = freq_count + both_count * 0.5 + never_count,
      sunratio = (freq_count + both_count * 0.5) / total) |> 
    mutate( sunratio = round(sunratio, 4)) |>
      select(YEAR, isco, sunratio) |> 
     left_join(data, by = c("YEAR", "isco")) |> 
      dplyr::select(-EVENWK, -NIGHTWK, -SATWK, -SUNWK)
  
  return(data)
} 
```

#### C. Proportion of employees by country, occupation and year.

This function is used to calculate the ISCOPROP variable, that represents the proportion of employees represented in each occupation classification, out of the total nÂº of employees, per year.

```{r}
# Function to calculate proportions by occupation and year
calculate_iscoprop <- function(data) {
  prop_data <- data |> 
    group_by(YEAR,isco) |> 
    summarise(employed = sum(EMPSTAT == 1)) |> 
    ungroup() |> 
    group_by(YEAR) |> 
    mutate(total = sum(employed)) |> 
    mutate(iscoprop = (employed / total) * 100) |> 
    dplyr::select(-employed, -total) 
  
  return(prop_data)
}

# Add ISCOPROP in the main dataframe
add_iscoprop <- function(data) {
  data <- data |> left_join(prop_data,by = c("YEAR", "isco"))
  return(data)
}
```

```{r}
total_employees <- function(data) {
data <- data |> 
  group_by(YEAR,isco) |> 
  summarise(totalemp = sum(EMPSTAT == 1)) |> 
  left_join(data, by = c("YEAR","isco"))

return(data)
}
```


Cada fila en prop_data representa la proporciÃ³n de empleados en una ocupaciÃ³n especÃ­fica para un aÃ±o especÃ­fico.

**Let's apply all the functions**

```{r}
for (country in names(country_data)) {
  filename <- country_data[[country]]
  cntdata <- read_csv(filename)
  cntdata <- female_ratio(cntdata)
  cntdata <- online_ratio(cntdata)
  cntdata <- ftpt_ratio(cntdata)
  cntdata <- supvisor_ratio(cntdata)
  cntdata <- extrahrs_ratio(cntdata)
  cntdata <- shiftwk_ratio(cntdata)
  cntdata <- shifts_ratio(cntdata)
  prop_data <- calculate_iscoprop(cntdata)
  cntdata <- add_iscoprop(cntdata)
  cntdata <- total_employees(cntdata)
  
  assign(country, cntdata)
  
}
```

Let's use the `distinct` function to keep only the unique values in the dataset. **Note that** each observation represents a unique year-occupation combination.

```{r}
# Lista para almacenar los nombres de los conjuntos de datos procesados
processed_datasets <- list()

# Iterar sobre los objetos en el entorno
for (obj_name in ls()) {
  # Verificar si el objeto es un dataframe y tiene el prefijo "country_code_"
  if (is.data.frame(get(obj_name)) && grepl("^[A-Z]{2}_", obj_name)) {
    # Obtener el dataframe
    data <- get(obj_name)
    
    # Apply distinct function
      data <- data %>%
      distinct(.keep_all = TRUE) 
    
    # Guardar el dataframe procesado en la lista
    processed_datasets[[obj_name]] <- data
  }
}

# Asignar los conjuntos de datos procesados a nuevos objetos en el entorno
for (obj_name in names(processed_datasets)) {
  assign(obj_name, processed_datasets[[obj_name]])
}
```

Let's merge all country datasets (2006-2021) and get rid of unnecessary noise in the isco variable.

```{r}
merged_data <- bind_rows(processed_datasets)
# Remove non-categorized values in job-isco
merged_data$isco[merged_data$isco %in% c(10,20,30,40,50,60,70,80,90,0)] <- NA
merged_data <- merged_data[!is.na(merged_data$isco), ]
```


#### D. Annual employment rate variation (2006-2021)

**The variable EMPSTAT** first distinguishes whether respondents between 15 and 89 years of age are employed or not; for respondents outside this age band, EMPSTAT is ânot applicableâ. If EMPSTAT is â1â (employed), ILOSTAT is â1â (employed) as well. EMPSTAT cases â2â (not employed) are then further derived to ILOSTAT â2â (unemployed) or â3â (outside the labour force), while persons aged below 15 and above 89 are considered as outside the labour force by definition.

**The new variable :employment rate variation** is calculated using the iscoprop variable (proportion of employees by year and occupation) to measure the yearly variation in employment.

```{r}
merged_data <- merged_data %>%
  group_by(COUNTRY, isco) %>%
  mutate(empchange = c(0, diff(iscoprop))) %>%
  ungroup()
```


The `isco_df` dataset contains the names of the occupations matching the isco variable, extracted from the **Joint Research Center**.
```{r}
isco_df<- read_csv("isco_df.csv")
merged_data<- left_join(merged_data,isco_df, by="isco")
```

Load the pre-processed `isco2d` data and create a mean score for each unique occupation.

```{r}
isco2d <- read.csv("isco2d.csv")
# Obtain the average score per occupation
iscoag <-isco2d |> 
  group_by(isco) |> 
  summarise_all(mean, na.rm = TRUE) |> 
    mutate_all(round, digits = 4) 
```

Create the main dataset (2012-2021). Merge both dataframes to include the other predictors we will use for our analysis EXPLAIN WHY

```{r}
# Subset and Merge (2012-2021)
merged_data_subset <- merged_data |> filter(YEAR >= 2012)
merged_data_subset <- merge(merged_data_subset,iscoag,by="isco")

# Organize the variables in both datasets
merged_data <- merged_data |> relocate(job,COUNTRY, .after = isco)# Dataset 2006-2021
merged_data_subset <- merged_data_subset |> relocate(job,COUNTRY, .after = isco)# Dataset 2012-2021
```

#### E. Aggregated employment rate variation (2012-2021)

```{r}
# Calculate the total average change per occupation
total_change_df <- merged_data_subset %>%
  group_by(job,isco) %>%
  summarise(avg_change = weighted.mean(empchange, weight = COUNTRY)*100) 

# Perform the left join with the main dataset
merged_data_subset <- left_join(merged_data_subset, total_change_df, by = c("job","isco")) 
```

## 3. OCCUPATIONS AND EMPLOYMENT IN EUROPE: DESCRIPTIVE RESULTS

Create 12 sectors of activity based on the 40 occupations.

```{r}
 merged_data_subset <- merged_data_subset %>%
  mutate(sector = case_when(
    str_detect(job, "Chief") ~"Public Sector",
    str_detect(job, "commercial|managers|hospitality|clerks|clerical") ~ "Administration",
    str_detect(job, "Science") ~ "Science and engineering",
    str_detect(job, "Health") ~ "Health and healthcare",
    str_detect(job, "Teaching") ~ "Education",
    str_detect(job, "Business|Sales") ~ "Finance, sales, and retail",
    str_detect(job, "Information") ~ "ICT",
    str_detect(job, "Legal") ~ "Legal, social and cultural",
    str_detect(job, "Personal|Protective") ~ "Care and social work",
    str_detect(job, "Market|farmers|Agricultural") ~ "Agriculture, forestry and fishing",
    str_detect(job, "Cleaners|preparation|Street|Refuse") ~ "Elementary services",
    TRUE ~ "Manufacturing"
  )) 

```

A New Class Schema Based on Differences in the Work Logic: Oesch Class Schema

```{r}
merged_data_subset <- merged_data_subset %>%
  mutate(occup = case_when(
    str_detect(job, "Chief| commercial|Production|Hospitality") ~"Directors and managers",
    str_detect(job, "clerks|clerical") ~ "Administrative support",
    str_detect(job, "Personal|Protective| Sales workers") ~ "Specialized workers",
    str_detect(job, "Market|farmers") ~ "Skilled workers", 
    str_detect(job, "Building|Metal|Handicraft|Electrical|Food processing") ~ "Trade workers", 
    str_detect(job, "Stationary|Assemblers|Drivers") ~ "Operators", 
    str_detect(job, "Cleaners|Labourers|fishery") ~ "Labourers", 
    str_detect(job, "Food preparation|Street|Refuse") ~ "Elementary workers", 
    TRUE ~ "Technicians and professionals"
  )) 
```

```{r, eval=FALSE}
library(openxlsx)
write.csv(merged_data_subset, file = "merged_data_subset.csv", row.names  = FALSE)
```

### Share of employment by sector of activity

```{r}
library(RColorBrewer)
# Total employees per YEAR
yearly_total <- merged_data_subset |> 
  group_by(YEAR) |> 
  summarise(total = sum(totalemp))

# Total employees per year and sector
sector_yearly_total <- merged_data_subset |> 
  group_by(YEAR, sector) |> 
  summarise(total_sector = sum(totalemp))

# Join by YEAR
sector_data <- sector_yearly_total |> 
  left_join(yearly_total, by = "YEAR") |> 
  mutate(secprop = total_sector / total * 100)

sector_data <- sector_data %>%
  arrange(YEAR, secprop)

# Convertir 'sector' en un factor con niveles ordenados
sector_data$sector <- factor(sector_data$sector, levels = rev(unique(sector_data$sector)))

### Visualization
ggplot(sector_data, aes(x = YEAR, y = secprop, color = sector)) +
  geom_line(size = 1.2) +  # Usar geom_line para las lÃ­neas
  geom_point(size = 2, shape = 21, fill = "white") + 
  labs(x="", y="") + lims(y = c(0,25)) + scale_color_brewer(palette = "Paired") + 
  theme_minimal() + theme(legend.title = element_blank())
```

### Cross-country differences in average employment change (2012-2021): ICT professionals vs Manufacturing

```{r}
tec<- merged_data_subset |> 
  group_by(COUNTRY,sector) |> 
  summarise(avg_country = weighted.mean(empchange, weight=COUNTRY)*100) |> 
  filter(str_detect(sector, "Information")) 

manu<-merged_data_subset |> 
  group_by(COUNTRY,sector) |> 
  summarise(avg_country = weighted.mean(empchange, weight=COUNTRY)*100) |> 
  filter(str_detect(sector, "manufacturing")) 
```

```{r}
library(maps)
xmin <- -10
xmax <- 40
ymin <- 35
ymax <- 70

#We need the country ID to merge the information into a world map dataset
europe<-giscoR::gisco_get_countries(resolution = "60",
    region="Europe") |> 
  select(CNTR_ID, geometry) |> 
left_join(tec, by = c("CNTR_ID" = "COUNTRY")) |> 
  na.omit()

map1<- ggplot() +
  geom_sf(data = europe, aes(fill = avg_country)) +
  scale_fill_gradient2(low = "#b70000", mid = "white", high = "darkgreen", name = "Average Change",midpoint = 0) +
   theme_void() + theme(
    legend.position = "none") + labs(title = "ICT")+
 coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax), expand = FALSE) 
```

```{r}
europe2<-giscoR::gisco_get_countries(resolution = "60",
    region="Europe") |> 
  select(CNTR_ID, geometry) |> 
left_join(manu, by = c("CNTR_ID" = "COUNTRY")) |> 
  na.omit()

map2<- ggplot() +
  geom_sf(data= europe2, aes(fill = avg_country)) +
   scale_fill_gradientn(
    colors = c("#b70000", "white", "darkgreen"), 
    values = rescale(c(-8, 0, 8)),
    breaks = c(-6, 0, 6),
    limits = c(-8, 8))+
  theme_void() + theme(
    legend.position = "right", 
    legend.title = element_blank(), legend.key.height = unit(1, "cm")) + 
  labs(title="Manufacturing")+ 
  coord_sf(xlim = c(xmin, xmax), ylim = c(ymin, ymax), expand = FALSE)
```

```{r}
# Arrange together
 map1 + map2
```

### Cross-country differences in average employment change (2012-2021) - GDP and Gini

```{r}
##Gini index
library(WDI) # API World Bank
var = WDI(indicator='SI.POV.GINI', country="all", extra=TRUE, latest=5) %>%
  mutate(Gini=SI.POV.GINI, COUNTRY=iso2c) %>% 
  group_by(COUNTRY) %>% 
  filter(year==2019) %>% 
  dplyr::select(COUNTRY, Gini) 

tec = merge(tec, var, by="COUNTRY", all.x = TRUE)
manu = merge(manu, var, by="COUNTRY", all.x = TRUE)


## GDP per capita (constant 2015 US$)
var = WDI(indicator='NY.GDP.PCAP.KD', country="all", extra=TRUE, latest=5) %>%
  mutate(GDP=NY.GDP.PCAP.KD, COUNTRY=iso2c) %>% 
  group_by(COUNTRY) %>% 
  filter(year=="2019") |> 
 dplyr::select(COUNTRY, GDP) 

tec = merge(tec, var, by="COUNTRY", all.x = TRUE)
manu = merge(manu, var, by="COUNTRY", all.x = TRUE)

```


```{r}
library(scales)
tec1<-ggplot(tec, aes(x = Gini, y = avg_country, color=Gini,label=COUNTRY)) +
  geom_point(aes(size = GDP), alpha = 0.6) +
  scale_size(range = c(0,20)) + 
  geom_text(vjust = -1, hjust = 0.5, size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +  
  scale_size(range = c(1,5)) + 
  scale_color_gradient(low = "darkgreen", high = "red") +
  scale_y_continuous(labels = function(x) percent(x / 100),  limits = c(-15, 25)) +
  labs(x = "", y = "", 
       title = "",
       subtitle = "") +
  theme_minimal() + guides(color = "none", size = "none")

manu1<-ggplot(manu, aes(x = Gini, y = avg_country, color=Gini,label=COUNTRY)) +
  geom_point(aes(size = GDP), alpha = 0.6) +
  scale_size(range = c(0,20)) + 
  geom_text(vjust = -1, hjust = 0.5, size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  scale_size(range = c(1,5)) + 
  scale_color_gradient(low = "darkgreen", high = "red") +
 scale_y_continuous(labels = function(x) percent(x / 100), limits = c(-15, 25)) +
  labs(x = "", y = "", 
       title = "",
       subtitle = "") +
  theme_minimal()

tec1 + manu1
```


### Occupational trends in the employment structure 

```{r}
merged_data_subset |> 
   mutate(ict = ifelse(ICT > 0.5, "High-ICT", "Low-ICT")) |> 
  select(job,ict) |> 
  filter(ict=="High-ICT") 
```


### Exploratory analysis of JRC variables

Correlations between relevant JRC variables

```{r}
# Repetitive and physical
cor1<- cor(isco2d$machines, isco2d$physical)
c1<-ggplot(isco2d, aes(x = machines, y = physical)) +geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs(subtitle = paste("Correlation coefficient:", round(cor1, 2)), x = "machines",y = "physical") 
# Repetitive and social
cor2 <- cor(isco2d$machines, isco2d$social)
c2<-ggplot(isco2d, aes(x = machines, y = social)) + geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs(subtitle = paste("Correlation coefficient:", round(cor2, 2)), x = "machines",y = "social") 
# Repetitive and intellectual
cor3 <- cor(isco2d$machines, isco2d$intellectual)
c3<-ggplot(isco2d, aes(x = machines, y = intellectual)) +geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs(subtitle = paste("Correlation coefficient:", round(cor3, 2)), x = "machines",y = "intellectual") 
# ICT and physical 
cor4 <- cor(isco2d$ICT, isco2d$physical)
c4<-ggplot(isco2d, aes(x = ICT, y = physical)) +geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs(subtitle = paste("Correlation coefficient:", round(cor4, 2)), x = "ICT",y = "physical") 
# ICT and social
cor5 <- cor(isco2d$ICT, isco2d$social)
c5<-ggplot(isco2d, aes(x = ICT, y = social)) +geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs(subtitle = paste("Correlation coefficient:", round(cor5, 2)), x = "ICT",y = "social") 
# ICT and intellectual
cor6 <- cor(isco2d$ICT, isco2d$intellectual)
c6<-ggplot(isco2d, aes(x = ICT, y = intellectual)) +geom_point(size=0.3, color="navyblue") +  
  geom_smooth(method = "lm", col = "darkred") +  # Regression line
  labs( subtitle = paste("Correlation coefficient:", round(cor6, 2)), x = "ICT",y = "intellectual") 

```

```{r}
# Arrange together
ggarrange(c1,c2,c3,c4,c5,c6,
          ncol =3, nrow=2) 
```


**Differences in occupational exposure to Basic ICT'S**

```{r}
selected <- merged_data_subset |> filter(str_detect(job,c("Information|construction"))) |> 
  distinct(job, .keep_all = TRUE)
# GrÃ¡fico ggplot con etiquetas seleccionadas
ggplot(merged_data_subset, aes(x = ICTadvanced, y = avg_change, color = ICTadvanced, size=avg_change)) +
   geom_point() +
   geom_text_repel(
    data = selected, 
    aes(label = job), 
    vjust = 10, 
    hjust = -0.1, 
    size = 7, 
    )  +

  scale_color_gradient(name= "Advanced ICT score",low = "#FF5733", high = "darkgreen",
                        guide = guide_colorbar(title.position = "top", title.vjust = 1)) +
    scale_size_continuous(name = "Employment variation", 
                        guide = guide_legend(title.position = "top", title.vjust = 1)) +
  labs (x="",y="") + 
  theme_minimal() +  
   theme(
    legend.position = "bottom") 

jpg_ecpol(ict, filename = "ict.jpg", width = 53, height = 20, unit = "cm", dpi = 300)

```
### Sector employment and occupational characteristics

```{r}
iscoag$sector <- merged_data_subset$sector[match(iscoag$isco,merged_data_subset$isco)] 
sector_ag <- iscoag |> dplyr::select(-isco)
sector_ag <- sector_ag |> 
  group_by(sector) |> 
   summarise(across(where(is.numeric), mean, na.rm = TRUE)) %>%
  mutate(across(where(is.numeric), ~ round(., digits = 4)))
```


```{r}
sector_long <- sector_ag |> 
    pivot_longer(cols = starts_with(c("ICT", "machines", "physical", "social", "intellectual")),
               names_to = "characteristic",
               values_to = "values") 

order <- c("physical", "social", "intellectual", "ICTbasic","ICT","ICTadvanced", "machines")

# Convertir characteristic a factor con el orden deseado
sector_long$characteristic <- factor(sector_long$characteristic, levels = order)
```

```{r fig.height=10, fig.width=10}
new_palette <-c("#8B0000", "#FF5733", "#228B22", "#006400", "#004d00")

 ggplot(sector_long, aes(x = characteristic, y = sector, size = values, color=values)) +
  geom_point(alpha = 1) +
  scale_size_continuous(range = c(0, 20), name = "Characteristic score",
                         guide = guide_legend(title.position = "top", title.vjust = 1)) + 
  scale_color_gradientn(colours = new_palette, name="Characteristic score",
                        guide = guide_colorbar(title.position = "top", title.vjust = 1)) + 
 theme_minimal() +
  theme(axis.text.x = element_text(angle = 0, hjust = 0.5, vjust = 15)) +  
  labs(title = "", x = "", y = "") +
  theme(
    axis.text.y = element_text(face = "bold", size = 14),
    axis.text.x = element_text(face = "bold", size = 11, vjust = 265),
                       legend.position = "top")

jpg_ecpol(bolas, filename = "bolas.jpg", width = 20, height = 50, unit = "cm", dpi = 300)
```

```{r}
jpg_ecpol <- function(plot, filename = "", width = 18, height = 12, unit = "cm", dpi = 300) {
  ggsave(
    plot = plot,
    filename = filename,
    device = 'jpg',
    width = width,
    height = height,
    unit = unit,
    dpi = dpi
  )
}
```



